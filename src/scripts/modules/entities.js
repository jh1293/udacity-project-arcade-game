/** @module modules/entities */

import Resources from './resources.js';
let resources = new Resources();

/** Class representing basic entity type. */
class Actor {
  /**
   * Create an actor.
   */
  constructor() {
    this.pos = {
      x: 0,
      y: 0
    };
    this.spriteImage = null;
    this.collision = {
      center: {
        x: 0,
        y: 0
      },
      radius: 0
    };
  }

  /**
   * Get width of current actor.
   * @return {number} Width of current actor.
   */
  get width() {
    return this.spriteImage.width;
  }

  /**
   * Get height of current actor.
   * @return {number} Height of current actor.
   */
  get height() {
    return this.spriteImage.height;
  }

  /**
   * Get sprite image of current actor.
   * @return {object} Sprite image of current actor.
   */
  get sprite() {
    return this.spriteImage;
  }

  /**
   * Set sprite image of current actor.
   * @param {string} resURL URL of image to be set as sprite image.
   */
  set sprite(resURL) {
    this.spriteImage = resources.load(resURL);
  }

  /**
   * Render current actor to a canvas 2d context.
   * @param {object} context The target context.
   */
  render(context) {
    context.drawImage(this.spriteImage, this.pos.x, this.pos.y, this.spriteImage.width, this.spriteImage.height);
  }
}

/**
 * Class representing player.
 * @extends Actor
 */
class Player extends Actor {
  /**
   * Create the player.
   */
  constructor() {
    super();
    this.dest = {
      x: 0,
      y: 0
    };
    this.interval = 0.05;  // Specify moving speed.
    this.isMoving = false;
  }

  /**
   * Update player's properties.
   * @param {number} delta Delta time generated by the engine.
   */
  update(delta) {

    // Moveable area restriction
    // '10' at the end of each expression is a tolerance value.
    if (this.dest.x < 0 - 10) {
      this.dest.x = this.pos.x;
    }
    if (this.dest.x > 500 - this.width + 10) {
      this.dest.x = this.pos.x;
    }
    if (this.dest.y < (-30) - 10) {
      this.dest.y = this.pos.y;
    }
    if (this.dest.y > 650 - this.height + 10) {
      this.dest.y = this.pos.y;
    }

    // Condition to win
    if (this.pos.y < -28) {
      let event = new CustomEvent('break', {detail: 'reach'});
      document.dispatchEvent(event);
    }

    // Update position properties
    this.pos.x += (this.dest.x - this.pos.x) / this.interval * delta;
    this.pos.y += (this.dest.y - this.pos.y) / this.interval * delta;
  }

  /**
   * Shift player to a new location.
   * @param {string} direction Direction implying player to be shifted.
   */
  shift(direction) {
    if (this.isMoving != true) {
      switch (direction) {
        case 'up':
          this.dest.y = this.pos.y - 80;
          break;
        case 'down':
          this.dest.y = this.pos.y + 80;
          break;
        case 'left':
          this.dest.x = this.pos.x - 100;
          break;
        case 'right':
          this.dest.x = this.pos.x + 100;
          break;
      }
      this.isMoving = true;
      setTimeout(() => {this.isMoving = false;}, this.interval * 4000);
    }
  }

  /**
   * Reset player to the original position.
   */
  reset() {
    this.dest.x = 200;
    this.dest.y = 450;
  }
}

/**
 * Class representing enemy.
 * @extends Actor
 */
class Enemy extends Actor {
  /**
   * Create an enemy.
   */
  constructor() {
    super();
    this.v = 100;  // Enemy's basic velocity
    this.r = Math.floor(Math.random() * 5) + 1;  // Enemy's velocity modifier, random number between 1-5
  }

  /**
   * Update enemy's properties.
   * @param {number} delta Delta time generated by the engine.
   */
  update(delta) {
    this.pos.x += this.v * this.r * delta;
    if (this.pos.x > 502) {
      this.pos.x = ((Math.random() * 3) + 1) * (-100);
      this.r = Math.floor(Math.random() * 5) + 1;
    }
  }
}

export { Actor, Player, Enemy };
